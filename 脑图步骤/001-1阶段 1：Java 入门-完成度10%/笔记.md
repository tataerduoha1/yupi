# 阶段 1：Java 入门

全文标志：

🚩进行中

🏁已完成

🏳️‍🌈未做

🏴不看

⭐推荐

## 前期准备

- 🏁 推荐使用 Markdown 语法编写，鱼皮教程：https://www.bilibili.com/video/BV1no4y1k7YT/

  - 工具

    - https://editor.mdnice.com/
    - 

  - github：https://github.com/younghz/Markdown 语法、教程
    - 使用`#`，可表示1-6级标题。

    > 1. 列表
    >
    > 2. > 嵌套
    >    >
    >    > ---
    >    >
>    > 分割线
    >    >
    >    > ----
    >    >
    >    > *斜体*
    >    >
    >    > # 标题1
    >    >
    >    > ## 标题2
    >    >
    >    > :ambulance:
    >    >
    >    > :banana:
    >    >
    >    > 




## JAVA编程基础（45天）

### 数组

```java
import java.util.Arrays;

public class Test {
    public static void main(String[] args) {
        //声明一维数组（数组中的数值型元素（包括byte、char、int、short、float、double、long）的默认值都是0。布尔型的默认值是false）,二维数组同理
        int[] ints = new int[5];
        int[] ints2 = {1, 2, 4, 3, 6};
        String str[] = {"1", "aa", "c"};
        String str2[] = new String[]{"1", "aa", "c"};
        //单个赋值
        str[0] = "11";

        //数组工具类Arrays(提供了 排序、查询等操作)
        Arrays.asList(new int[]{1, 5, 7, 0, 17});
        Arrays.sort(ints2);
        for (int i = 0; i < ints2.length; i++) {
            System.out.print(ints2[i] + " ");
        }
        System.out.println();
        System.out.println("3的位置是:" + Arrays.binarySearch(ints2, 3));
    }
}
```

#### 数组内存：

![数组内存](/img/数组内存.png)



### 面向对象

#### 重载

```java
/**
 * 重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。
 * 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。
 * 最常用的地方就是构造器的重载。
 *
 * 重载规则:
 * 被重载的方法必须改变参数列表(参数个数或类型不一样)；
 * 被重载的方法可以改变返回类型；
 * 被重载的方法可以改变访问修饰符；
 * 被重载的方法可以声明新的或更广的检查异常；
 * 方法能够在同一个类中或者在一个子类中被重载。
 * 无法以返回值类型作为重载函数的区分标准。
 */
public class Test {

    public String printStr(String str) {
        return str;
    }

    public int printStr(int a) {
        return a;
    }
}
```

#### 封装

```java
/**
 * 在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。
 *
 * 封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。
 * 要访问该类的代码和数据，必须通过严格的接口控制。
 * 封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。
 * 适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。
 *
 * 封装的优点
 * 1. 良好的封装能够减少耦合。
 * 2. 类内部的结构可以自由修改。
 * 3. 可以对成员变量进行更精确的控制。
 * 4. 隐藏信息，实现细节。
 */
public class Test {
    
    private String fieldOne = "1";

    // 字段和转换的逻辑封装，只留一个public方法给外界。后续我可以修改逻辑，而其他地方不需要改
    private int convertStr2Int(){
        return Integer.parseInt(fieldOne);
    }
    
    public int getFieldOne(){
        return convertStr2Int();
    }
}
```

#### 多态

```java
/**
 * 多态是同一个行为具有多个不同表现形式或形态的能力。
 *
 * 多态就是同一个接口，使用不同的实例而执行不同操作
 * 
 * 多态的优点
 * 1. 消除类型之间的耦合关系
 * 2. 可替换性
 * 3. 可扩充性
 * 4. 接口性
 * 5. 灵活性
 * 6. 简化性
 * 
 * 多态存在的三个必要条件:
 * 继承
 * 重写
 * 父类引用指向子类对象：Parent p = new Child();
 */
public class Test{
    void draw(){};
}

class TestChild1 extends Test{
    @Override
    void draw(){
        System.out.println("I am child 1");
    }
}

class TestChild2 extends Test{
    @Override
    void draw(){
        System.out.println("I am child 2");
    }
}
```

### 枚举

```java
public class Test{
    public static void main(String[] args) {
        System.out.println(People.BLACK.getAgeByPeopleType());
    }
}

enum People{
    WHITE("英国", "32岁", "173cm"),
    BLACK("古巴", "2岁", "183cm"),
    YELLOW("日本", "18岁", "190cm");

    String nation;
    String age;
    String height;
    
    People(String nation, String age, String height){
        this.nation = nation;
        this.age = age;
        this.height = height;
    }

    public String getAgeByPeopleType() {
        return age;
    }
}
```

### 常用类

#### String类

*字符串广泛应用 在 Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。String 类有 11 种构造方法*

**创建字符串**：

```java
String str = "Runoob";
String str2=new String("Runoob");

String s1 = "Runoob";              // String 直接创建
String s2 = "Runoob";              // String 直接创建
String s3 = s1;                    // 相同引用
String s4 = new String("Runoob");   // String 对象创建
String s5 = new String("Runoob");   // String 对象创建
```

![String不同创建方式内存](/img/String不同创建方式内存.png)

**注意:**

*String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了。 如果需要对字符串做很多修改，那么应该选择使用 StringBuffer & StringBuilder 类。*

String 类是不可改变的解析，例如：

```
String s = "Google";
System.out.println("s = " + s);

s = "Runoob";
System.out.println("s = " + s);
```

输出结果为：

```
Google
Runoob
```

从结果上看是改变了，但为什么门说String对象是不可变的呢？

*原因在于实例中的 **s** 只是一个 **String** 对象的引用，并不是对象本身，当执行 **s = "Runoob";** 创建了一个新的对象 "Runoob"，而原来的 "Google" 还存在于内存中。*



#### 日期时间

> java.util 包提供了 Date 类来封装当前的日期和时间。 Date 类提供两个构造函数来实例化 Date 对象。
>
> 第一个构造函数使用当前日期和时间来初始化对象。
>
> Date( )
>
> 第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。
>
> Date(long millisec)

```java
import java.text.SimpleDateFormat;
import java.util.Date;

public class Test {
    public static void main(String[] args) {
        // 初始化 Date 对象
        Date date = new Date();

        // 使用 toString() 函数显示日期时间
        System.out.println(date.toString());

        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        System.out.println(simpleDateFormat.format(date));
    }
}

//输出结果：
Sat Nov 13 19:41:40 CST 2021
2021-11-13 19:41:40
```

### 集合类

> 早在 Java 2 中之前，Java 就提供了特设类。比如：Dictionary, Vector, Stack, 和 Properties 这些类用来存储和操作对象组。
>
> 虽然这些类都非常有用，但是它们缺少一个核心的，统一的主题。由于这个原因，使用 Vector 类的方式和使用 Properties 类的方式有着很大不同。
>
> 集合框架被设计成要满足以下几个目标。
>
> - 该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。
> - 该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。
> - 对一个集合的扩展和适应必须是简单的。
>
> 为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： **LinkedList**, **HashSet**, 和 **TreeSet** 等,除此之外你也可以通过这些接口实现自己的集合。
>
> 
>
> ![JAVA集合框架图](/img/JAVA集合框架图.gif)
>
> 从上面的集合框架图可以看到，Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 [ArrayList](https://www.runoob.com/java/java-arraylist.html)、[LinkedList](https://www.runoob.com/java/java-linkedlist.html)、[HashSet](https://www.runoob.com/java/java-hashset.html)、LinkedHashSet、[HashMap](https://www.runoob.com/java/java-hashmap.html)、LinkedHashMap 等等.
>
> 
>
> **集合框架体系如图所示**:
>
> ![集合框架体系](/img/集合框架体系.png)
>
> 

### 泛型

泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法。

#### 泛型类

```java
class 类名称 <泛型标识：可以随便写任意标识号，标识指定的泛型的类型>{
  private 泛型标识 /*（成员变量类型）*/ var; 
	 .....
  }
}

//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
//在实例化泛型类时，必须指定T的具体类型
public class Generic<T>{ 
    //key这个成员变量的类型为T,T的类型由外部指定  
    private T key;

    public Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定
        this.key = key;
    }

    public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定
        return key;
    }
}
```



#### 泛型接口

泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中.

```java
//定义一个泛型接口
public interface Generator<T> {
    public T next();
}


/**
 * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中
 * 即：class FruitGenerator<T> implements Generator<T>{
 * 如果不声明泛型，如：class FruitGenerator implements Generator<T>，编译器会报错："Unknown class"
 */
class FruitGenerator<T> implements Generator<T>{
    @Override
    public T next() {
        return null;
    }
}


/**
 * 传入泛型实参时：
 * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator<T>
 * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。
 * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型
 * 即：Generator<T>，public T next();中的的T都要替换成传入的String类型。
 */
public class FruitGenerator implements Generator<String> {

    private String[] fruits = new String[]{"Apple", "Banana", "Pear"};

    @Override
    public String next() {
        Random rand = new Random();
        return fruits[rand.nextInt(3)];
    }
}


我们知道Ingeter是Number的一个子类，同时在特性章节中我们也验证过Generic<Ingeter>与Generic<Number>实际上是相同的一种基本类型。那么问题来了，在使用Generic<Number>作为形参的方法中，能否使用Generic<Ingeter>的实例传入呢？在逻辑上类似于Generic<Number>和Generic<Ingeter>是否可以看成具有父子关系的泛型类型呢？
//Generic<Integer>不能被看作为`Generic<Number>的子类。由此可以看出:同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。
//回到上面的例子，如何解决上面的问题？总不能为了定义一个新的方法来处理Generic<Integer>类型的类，这显然与java中的多台理念相违背。因此我们需要一个在逻辑上可以表示同时是Generic<Integer>和Generic<Number>父类的引用类型。由此类型通配符应运而生。
//我们可以将上面的方法改一下：
public void showKeyValue1(Generic<?> obj){
    Log.d("泛型测试","key value is " + obj.getKey());
}
//类型通配符一般是使用？代替具体的类型实参，注意了，此处’？’是类型实参，而不是类型形参 。重要说三遍！此处’？’是类型实参，而不是类型形参 ！ 此处’？’是类型实参，而不是类型形参 ！再直白点的意思就是，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。

//可以解决当具体类型不确定的时候，这个通配符就是 ?  ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。
```



#### 泛型方法

```java
/**
 * 泛型方法的基本介绍
 * @param tClass 传入的泛型实参
 * @return T 返回值为T类型
 * 说明：
 *     1）public 与 返回值中间<T>非常重要，可以理解为声明此方法为泛型方法。
 *     2）只有声明了<T>的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。
 *     3）<T>表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。
 *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。
 */
public <T> T genericMethod(Class<T> tClass)throws InstantiationException ,
  IllegalAccessException{
        T instance = tClass.newInstance();
        return instance;
}
```

```java
public class GenericTest {
    //这个类是个泛型类，在上面已经介绍过
    public class Generic<T>{
        private T key;

        public Generic(T key) {
            this.key = key;
        }

        //我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。
        //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。
        //所以在这个方法中才可以继续使用 T 这个泛型。
        public T getKey(){
            return key;
        }

        /**
         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息"cannot reslove symbol E"
         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。
         public E setKey(E key){
         this.key = keu
         }
         */
    }

    /**
     * 这才是一个真正的泛型方法。
     * 首先在public与返回值之间的<T>必不可少，这表明这是一个泛型方法，并且声明了一个泛型T
     * 这个T可以出现在这个泛型方法的任意位置.
     * 泛型的数量也可以为任意多个
     *    如：public <T,K> K showKeyName(Generic<T> container){
     *        ...
     *        }
     */
    public <T> T showKeyName(Generic<T> container){
        System.out.println("container key :" + container.getKey());
        //当然这个例子举的不太合适，只是为了说明泛型方法的特性。
        T test = container.getKey();
        return test;
    }

    //这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic<Number>这个泛型类做形参而已。
    public void showKeyValue1(Generic<Number> obj){
        System.out.println("泛型测试 key value is " + obj.getKey());;
    }

    //这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?
    //同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类
    public void showKeyValue2(Generic<?> obj){
        System.out.println("泛型测试key value is " + obj.getKey());
    }

    /**
     * 这个方法是有问题的，编译器会为我们提示错误信息："UnKnown class 'E' "
     * 虽然我们声明了<T>,也表明了这是一个可以处理泛型的类型的泛型方法。
     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。
     public <T> T showKeyName(Generic<E> container){
     ...
     }
     */

    /**
     * 这个方法也是有问题的，编译器会为我们提示错误信息："UnKnown class 'T' "
     * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。
     * 所以这也不是一个正确的泛型方法声明。
     public void showkey(T genericObj){

     }
     */

    public static void main(String[] args) {


    }
}
```

```java
public class GenericFruit {
    class Fruit{
        @Override
        public String toString() {
            return "fruit";
        }
    }

    class Apple extends Fruit{
        @Override
        public String toString() {
            return "apple";
        }
    }

    class Person{
        @Override
        public String toString() {
            return "Person";
        }
    }

    class GenerateTest<T>{
        public void show_1(T t){
            System.out.println(t.toString());
        }

        //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。
        //由于泛型方法在声明的时候会声明泛型<E>，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。
        public <E> void show_3(E t){
            System.out.println(t.toString());
        }

        //在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。
        public <T> void show_2(T t){
            System.out.println(t.toString());
        }
    }

    public static void main(String[] args) {
        Apple apple = new Apple();
        Person person = new Person();

        GenerateTest<Fruit> generateTest = new GenerateTest<Fruit>();
        //apple是Fruit的子类，所以这里可以
        generateTest.show_1(apple);
        //编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person
        //generateTest.show_1(person);

        //使用这两个方法都可以成功
        generateTest.show_2(apple);
        generateTest.show_2(person);

        //使用这两个方法也都可以成功
        generateTest.show_3(apple);
        generateTest.show_3(person);
    }
}
```

##### 泛型方法与可变参数

```java
public class GenericFruit {
    public <T> void printMsg( T... args){
        for(T t : args){
            Log.d("泛型测试","t is " + t);
        }
    }
}
```

##### 静态方法与泛型

```java
public class StaticGenerator<T> {
    /**
     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）
     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。
     * 如：public static void show(T t){..},此时编译器会提示错误信息：
     "StaticGenerator cannot be refrenced from static context"
     */
    public static <T> void show(T t){

    }
}
```

#### 泛型上下边界

*在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。为泛型添加上边界，即传入的类型实参必须是指定类型的子类型*

```java
public void showKeyValue1(Generic<? extends Number> obj){
    Log.d("泛型测试","key value is " + obj.getKey());
}

//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的<T>上添加上下边界，即在泛型声明的时候添加
//public <T> T showKeyName(Generic<T extends Number> container)，编译器会报错："Unexpected bound"
public <T extends Number> T showKeyName(Generic<T> container){
    System.out.println("container key :" + container.getKey());
    T test = container.getKey();
    return test;
}
```

#### 泛型数组

看到了很多文章中都会提起泛型数组，经过查看sun的说明文档，在java中是”不能创建一个确切的泛型类型的数组”的。

也就是说下面的这个例子是不可以的：

```
List<String>[] ls = new ArrayList<String>[10];  
```

而使用通配符创建泛型数组是可以的，如下面这个例子：

```
List<?>[] ls = new ArrayList<?>[10]; 
```

这样也是可以的：

```
List<String>[] ls = new ArrayList[10];
```

### **注解**

#### ***内置的注解：***

Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在java.lang.annotation 中。

***作用在代码的注解是：***

- @Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。
- @Deprecated - 标记过时方法。如果使用该方法，会报编译警告。
- @SuppressWarnings - 指示编译器去忽略注解中声明的警告。

***作用在其他注解的注解***(或者说 元注解)是:

- @Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。
- @Documented - 标记这些注解是否包含在用户文档中。
- @Target - 标记这个注解应该是哪种 Java 成员。
- @Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)

从 Java 7 开始，额外添加了 3 个注解:

- @SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。
- @FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。
- @Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。

#### ***注解架构：***

![注解架构](/img/注解架构.jpg)

> 从中，我们可以看出：
>
> > **(01) 1 个 Annotation 和 1 个 RetentionPolicy 关联。**
> >
> > 可以理解为：每1个Annotation对象，都会有唯一的RetentionPolicy属性。
> >
> > **(02) 1 个 Annotation 和 1~n 个 ElementType 关联。**
> >
> > 可以理解为：对于每 1 个 Annotation 对象，可以有若干个 ElementType 属性。
> >
> > **(03) Annotation 有许多实现类，包括：Deprecated, Documented, Inherited, Override 等等。**
> >
> > Annotation 的每一个实现类，都 "和 1 个 RetentionPolicy 关联" 并且 " 和 1~n 个 ElementType 关联"。

> java Annotation 的组成中，有 3 个非常重要的主干类。它们分别是：
>
> 
>
> ***Annotation.java***
>
> > **package** java.lang.annotation;
> > **public** **interface** Annotation {
> >
> >   **boolean** equals(Object obj);
> >
> >   **int** hashCode();
> >
> >   String toString();
> >
> >   Class<? **extends** Annotation> annotationType();
> > }
>
> 
>
> ***ElementType.java***
>
> > **package** java.lang.annotation;
> >
> > **public** **enum** ElementType {
> >   TYPE,        */\* 类、接口（包括注释类型）或枚举声明  \*/*
> >
> >   FIELD,        */\* 字段声明（包括枚举常量）  \*/*
> >
> >   METHOD,       */\* 方法声明  \*/*
> >
> >   PARAMETER,      */\* 参数声明  \*/*
> >
> >   CONSTRUCTOR,     */\* 构造方法声明  \*/*
> >
> >   LOCAL_VARIABLE,   */\* 局部变量声明  \*/*
> >
> >   ANNOTATION_TYPE,   */\* 注释类型声明  \*/*
> >
> >   **PACKAGE**       */\* 包声明  \*/*
> > }
>
> 
>
> ***RetentionPolicy.java***
>
> > **package** java.lang.annotation;
> > **public** **enum** RetentionPolicy {
> >   SOURCE,       */\* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了  \*/*
> >
> >   **CLASS**,       */\* 编译器将Annotation存储于类对应的.class文件中。默认行为  \*/*
> >
> >   RUNTIME       */\* 编译器将Annotation存储于class文件中，并且可由JVM读入 \*/*
> > }

#### 注解定义

```java
@Documented
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation1 {
}
```

> 说明：
>
> 上面的作用是定义一个 Annotation，它的名字是 MyAnnotation1。定义了 MyAnnotation1 之后，我们可以在代码中通过 *@MyAnnotation1* 来使用它。 其它的，@Documented, @Target, @Retention, @interface 都是来修饰 MyAnnotation1 的。下面分别说说它们的含义：
>
> **(01) @interface**
>
> 使用 @interface 定义注解时，意味着它实现了 java.lang.annotation.Annotation 接口，即该注解就是一个Annotation。
>
> 定义 Annotation 时，@interface 是必须的。
>
> 注意：它和我们通常的 implemented 实现接口的方法不同。Annotation 接口的实现细节都由编译器完成。通过 @interface 定义注解后，该注解不能继承其他的注解或接口。
>
> **(02) @Documented**
>
> 类和方法的 Annotation 在缺省情况下是不出现在 javadoc 中的。如果使用 @Documented 修饰该 Annotation，则表示它可以出现在 javadoc 中。
>
> 定义 Annotation 时，@Documented 可有可无；若没有定义，则 Annotation 不会出现在 javadoc 中。
>
> **(03) @Target(ElementType.TYPE)**
>
> 前面我们说过，ElementType 是 Annotation 的类型属性。而 @Target 的作用，就是来指定 Annotation 的类型属性。
>
> @Target(ElementType.TYPE) 的意思就是指定该 Annotation 的类型是 ElementType.TYPE。这就意味着，MyAnnotation1 是来修饰"类、接口（包括注释类型）或枚举声明"的注解。
>
> 定义 Annotation 时，@Target 可有可无。若有 @Target，则该 Annotation 只能用于它所指定的地方；若没有 @Target，则该 Annotation 可以用于任何地方。
>
> **(04) @Retention(RetentionPolicy.RUNTIME)**
>
> 前面我们说过，RetentionPolicy 是 Annotation 的策略属性，而 @Retention 的作用，就是指定 Annotation 的策略属性。
>
> @Retention(RetentionPolicy.RUNTIME) 的意思就是指定该 Annotation 的策略是 RetentionPolicy.RUNTIME。这就意味着，编译器会将该 Annotation 信息保留在 .class 文件中，并且能被虚拟机读取。
>
> 定义 Annotation 时，@Retention 可有可无。若没有 @Retention，则默认是 RetentionPolicy.CLASS。

#### **java 常用的 Annotation：**

```java
@Deprecated  -- @Deprecated 所标注内容，不再被建议使用。
@Override    -- @Override 只能标注方法，表示该方法覆盖父类中的方法。
@Documented  -- @Documented 所标注内容，可以出现在javadoc中。
@Inherited   -- @Inherited只能被用来标注“Annotation类型”，它所标注的Annotation具有继承性。
@Retention   -- @Retention只能被用来标注“Annotation类型”，而且它被用来指定Annotation的RetentionPolicy属性。
@Target      -- @Target只能被用来标注“Annotation类型”，而且它被用来指定Annotation的ElementType属性。
@SuppressWarnings -- @SuppressWarnings 所标注内容产生的警告，编译器会对这些警告保持静默。
```

- **@Deprecated**

  @Deprecated 的定义如下：

  ```java
  @Documented
  @Retention(RetentionPolicy.RUNTIME)
  public @interface Deprecated {
  }
  ```

  > 说明：
  >
  > - (01) @interface -- 它的用来修饰 Deprecated，意味着 Deprecated 实现了 java.lang.annotation.Annotation 接口；即 Deprecated 就是一个注解。 
  > - (02) @Documented -- 它的作用是说明该注解能出现在 javadoc 中。
  > - (03) @Retention(RetentionPolicy.RUNTIME) -- 它的作用是指定 Deprecated 的策略是 RetentionPolicy.RUNTIME。这就意味着，编译器会将Deprecated 的信息保留在 .class 文件中，并且能被虚拟机读取。
  > - (04) @Deprecated 所标注内容，不再被建议使用。

#### spring容器的aop+反射 机制 使得 java注解生效

```java

import com.ql.entity.LoginUser;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

/**
 * @author qinlei
 * @email qlanto_147@163.com
 * @date 2020/11/21 11:23
 */
@Aspect
@Component
public class InjectRealNameAspect {

    /**
     * 切入点
     */
    @Pointcut("@annotation(com.ql.aspect.InjectRealName)")
    public void injectPointCut() {

    }

    /**
     * 环绕模式
     * @param point
     * @return
     * @throws Throwable
     */
    @Around("injectPointCut()")
    public Object around(ProceedingJoinPoint point) throws Throwable {
        //获取调用方法传入的参数
        Object[] args = point.getArgs();
        MethodSignature signature = (MethodSignature) point.getSignature();
        Method method = signature.getMethod();
        InjectRealName injectRealName = method.getAnnotation(InjectRealName.class);
        //第一个参数
        //第一个参数必须是需要操作的实体类
        int methodType = injectRealName.method();
        //通过shiro获取当前操作人信息
        // LoginUser sysUser = (LoginUser) SecurityUtils.getSubject().getPrincipal();
        //此处直接给出
        LoginUser sysUser = new LoginUser("qlanto");
        
        //0更新 1修改
        if(methodType == 0){
            InjectRealNameAspect.setPrivateField(args[0],"createBy",sysUser.getRealname());
        }else{
            InjectRealNameAspect.setPrivateField(args[0],"updateBy",sysUser.getRealname());
        }
        //执行方法
        Object result = point.proceed();
        return result;
    }

    /**
     * 设置私有成员的值
     * @param instance
     * @param fieldName
     * @param value
     * @throws NoSuchFieldException
     * @throws IllegalAccessException
     */
    public static void setPrivateField(Object instance, String fieldName, Object value) throws NoSuchFieldException, IllegalAccessException {
        Field field = instance.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(instance, value);
    }


}
```

#### spring AOP实现原理

AOP实现原理是动态代理，讲到动态代理就不得不说代理模式了， 代理模式的定义：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理又分为静态代理和动态代理，动态代理采用的就是JDK代理。

#### 动态代理、静态代理

##### 静态代理

首先，我们创建一个Person接口。这个接口就是学生（被代理类），和班长（代理类）的公共接口，他们都有交作业的行为。这样，学生交作业就可以让班长来代理执行。

```java
/**
 * Created by Mapei on 2018/11/7
 * 创建person接口
 */
public interface Person {
    //交作业
    void giveTask();
}
```

Student类实现Person接口，Student可以具体实施交作业这个行为。

```java
/**
 * Created by Mapei on 2018/11/7
 */
public class Student implements Person {
    private String name;
    public Student(String name) {
        this.name = name;
    }
 
    public void giveTask() {
        System.out.println(name + "交语文作业");
    }
}
```

StudentsProxy类，这个类也实现了Person接口，但是还另外持有一个学生类对象，那么他可以代理学生类对象执行交作业的行为。

```java
/**
 * Created by Mapei on 2018/11/7
 * 学生代理类，也实现了Person接口，保存一个学生实体，这样就可以代理学生产生行为
 */
public class StudentsProxy implements Person{
    //被代理的学生
    Student stu;
 
    public StudentsProxy(Person stu) {
        // 只代理学生对象
        if(stu.getClass() == Student.class) {
            this.stu = (Student)stu;
        }
    }
 
    //代理交作业，调用被代理学生的交作业的行为
    public void giveTask() {
        stu.giveTask();
    }
}
```

下面测试一下，看代理模式如何使用：

```java
/**
 * Created by Mapei on 2018/11/7
 */
public class StaticProxyTest {
    public static void main(String[] args) {
        //被代理的学生林浅，他的作业上交有代理对象monitor完成
        Person linqian = new Student("林浅");
 
        //生成代理对象，并将林浅传给代理对象
        Person monitor = new StudentsProxy(linqian);
 
        //班长代理交作业
        monitor.giveTask();
    }
}
```

> 这里并没有直接通过林浅（被代理对象）来执行交作业的行为，而是通过班长（代理对象）来代理执行了。这就是代理模式。代理模式就是在访问实际对象时引入一定程度的间接性，这里的间接性就是指不直接调用实际对象的方法，那么我们在代理过程中就可以加上一些其他用途。比如班长在帮林浅交作业的时候想告诉老师最近林浅的进步很大，就可以轻松的通过代理模式办到。在代理类的交作业之前加入方法即可。这个优点就可以运用在spring中的AOP，我们能在一个切点之前执行一些操作，在一个切点之后执行一些操作，这个切点就是一个个方法。这些方法所在类肯定就是被代理了，在代理过程中切入了一些其他操作。

##### 动态代理

>动态代理和静态代理的区别是，静态代理的的代理类是我们自己定义好的，在程序运行之前就已经变异完成，但是动态代理的代理类是在程序运行时创建的。相比于静态代理，动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。比如我们想在每个代理方法之前都加一个处理方法，我们上面的例子中只有一个代理方法，如果还有很多的代理方法，就太麻烦了，我们来看下动态代理是怎么去实现的。

首先还是定义一个Person接口:

```java
/**
 * Created by Mapei on 2018/11/7
 * 创建person接口
 */
public interface Person {
    //交作业
    void giveTask();
}
```

接下来是创建需要被代理的实际类，也就是学生类：

```java

/**
 * Created by Mapei on 2018/11/7
 */
public class Student implements Person {
    private String name;
    public Student(String name) {
        this.name = name;
    }
 
    public void giveTask() {
        System.out.println(name + "交语文作业");
    }
}
```

创建StuInvocationHandler类，实现InvocationHandler接口，这个类中持有一个被代理对象的实例target。InvocationHandler中有一个invoke方法，所有执行代理对象的方法都会被替换成执行invoke方法。

```java

/**
 * Created by Mapei on 2018/11/7
 */
public class StuInvocationHandler<T> implements InvocationHandler {
    //invocationHandler持有的被代理对象
    T target;
 
    public StuInvocationHandler(T target) {
        this.target = target;
    }
 
    /**
     * proxy:代表动态代理对象
     * method：代表正在执行的方法
     * args：代表调用目标方法时传入的实参
     */
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("代理执行" +method.getName() + "方法");
        Object result = method.invoke(target, args);
        return result;
    }
}
```

那么接下来我们就可以具体的创建代理对象了。

```java
/**
 * Created by Mapei on 2018/11/7
 * 代理类
 */
public class ProxyTest {
    public static void main(String[] args) {
 
        //创建一个实例对象，这个对象是被代理的对象
        Person linqian = new Student("林浅");
 
        //创建一个与代理对象相关联的InvocationHandler
        InvocationHandler stuHandler = new StuInvocationHandler<Person>(linqian);
 
        //创建一个代理对象stuProxy来代理linqian，代理对象的每个执行方法都会替换执行Invocation中的invoke方法
        Person stuProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class<?>[]{Person.class}, stuHandler);
 
        //代理执行交作业的方法
        stuProxy.giveTask();
    }
}
```

那么到这里问题就来了，为什么代理对象执行的方法都会通过InvocationHandler中的invoke方法来执行，带着这个问题，我们需要看一下动态代理的源码，对他进行简单的分析。

上面我们使用Proxy类的newProxyInstance方法创建了一个动态代理对象，看一下他的源码：

```java
public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)
        throws IllegalArgumentException
    {
        Objects.requireNonNull(h);
 
        final Class<?>[] intfs = interfaces.clone();
        final SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
        }
 
        /*
         * Look up or generate the designated proxy class.
         */
        Class<?> cl = getProxyClass0(loader, intfs);
 
        /*
         * Invoke its constructor with the designated invocation handler.
         */
        try {
            if (sm != null) {
                checkNewProxyPermission(Reflection.getCallerClass(), cl);
            }
 
            final Constructor<?> cons = cl.getConstructor(constructorParams);
            final InvocationHandler ih = h;
            if (!Modifier.isPublic(cl.getModifiers())) {
                AccessController.doPrivileged(new PrivilegedAction<Void>() {
                    public Void run() {
                        cons.setAccessible(true);
                        return null;
                    }
                });
            }
            return cons.newInstance(new Object[]{h});
        } catch (IllegalAccessException|InstantiationException e) {
            throw new InternalError(e.toString(), e);
        } catch (InvocationTargetException e) {
            Throwable t = e.getCause();
            if (t instanceof RuntimeException) {
                throw (RuntimeException) t;
            } else {
                throw new InternalError(t.toString(), t);
            }
        } catch (NoSuchMethodException e) {
            throw new InternalError(e.toString(), e);
        }
  }
```

然后，我们需要重点关注Class<?> cl = getProxyClass0(loader, intfs)这句代码，这里产生了代理类，这个类就是动态代理的关键，由于是动态生成的类文件，我们将这个类文件打印到文件中。

```java

        byte[] classFile = ProxyGenerator.generateProxyClass("$Proxy0", Student.class.getInterfaces());
        String path = "/Users/mapei/Desktop/okay/65707.class";
 
        try{
            FileOutputStream fos = new FileOutputStream(path);
            fos.write(classFile);
            fos.flush();
            System.out.println("代理类class文件写入成功");
        }catch (Exception e) {
            System.out.println("写文件错误");
        }
```

对这个class文件进行反编译，我们看看jdk为我们生成了什么样的内容：

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.lang.reflect.UndeclaredThrowableException;
import proxy.Person;
 
public final class $Proxy0 extends Proxy implements Person
{
  private static Method m1;
  private static Method m2;
  private static Method m3;
  private static Method m0;
  
  /**
  *注意这里是生成代理类的构造方法，方法参数为InvocationHandler类型，看到这，是不是就有点明白
  *为何代理对象调用方法都是执行InvocationHandler中的invoke方法，而InvocationHandler又持有一个
  *被代理对象的实例，就可以去调用真正的对象实例。
  */
  public $Proxy0(InvocationHandler paramInvocationHandler)
    throws 
  {
    super(paramInvocationHandler);
  }
  
  //这个静态块本来是在最后的，我把它拿到前面来，方便描述
   static
  {
    try
    {
      //看看这儿静态块儿里面的住giveTask通过反射得到的名字m3，其他的先不管
      m1 = Class.forName("java.lang.Object").getMethod("equals", new Class[] { Class.forName("java.lang.Object") });
      m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]);
      m3 = Class.forName("proxy.Person").getMethod("giveTask", new Class[0]);
      m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]);
      return;
    }
    catch (NoSuchMethodException localNoSuchMethodException)
    {
      throw new NoSuchMethodError(localNoSuchMethodException.getMessage());
    }
    catch (ClassNotFoundException localClassNotFoundException)
    {
      throw new NoClassDefFoundError(localClassNotFoundException.getMessage());
    }
  }
 
  /**
  * 
  *这里调用代理对象的giveMoney方法，直接就调用了InvocationHandler中的invoke方法，并把m3传了进去。
  *this.h.invoke(this, m3, null);我们可以对将InvocationHandler看做一个中介类，中介类持有一个被代理对象，在invoke方法中调用了被代理对象的相应方法。通过聚合方式持有被代理对象的引用，把外部对invoke的调用最终都转为对被代理对象的调用。
  */
  public final void giveTask()
    throws 
  {
    try
    {
      this.h.invoke(this, m3, null);
      return;
    }
    catch (Error|RuntimeException localError)
    {
      throw localError;
    }
    catch (Throwable localThrowable)
    {
      throw new UndeclaredThrowableException(localThrowable);
    }
  }
 
}
```

##### AOP实现

看完了动态代理的源码，我们接下来就要看一下Spring中AOP实现的源码是怎样的？

***aop创建代理的源码分析***

看一下bean如何被包装为proxy：

```java
protected Object createProxy(
   		Class<?> beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) {
   		
   	if (this.beanFactory instanceof ConfigurableListableBeanFactory) {
   		AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);
   	}
 
       // 1.创建proxyFactory，proxy的生产主要就是在proxyFactory做的
   	ProxyFactory proxyFactory = new ProxyFactory();
   	proxyFactory.copyFrom(this);
 
   	if (!proxyFactory.isProxyTargetClass()) {
   		if (shouldProxyTargetClass(beanClass, beanName)) {
   			proxyFactory.setProxyTargetClass(true);
   		}
   		else {
   			evaluateProxyInterfaces(beanClass, proxyFactory);
   		}
   	}
 
       // 2.将当前bean适合的advice，重新封装下，封装为Advisor类，然后添加到ProxyFactory中
   	Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);
   	for (Advisor advisor : advisors) {
   		proxyFactory.addAdvisor(advisor);
   	}
 
   	proxyFactory.setTargetSource(targetSource);
   	customizeProxyFactory(proxyFactory);
 
   	proxyFactory.setFrozen(this.freezeProxy);
   	if (advisorsPreFiltered()) {
   		proxyFactory.setPreFiltered(true);
   	}
 
       // 3.调用getProxy获取bean对应的proxy
   	return proxyFactory.getProxy(getProxyClassLoader());
   }
```

创建何种类型的Proxy？JDKProxy还是CGLIBProxy？

```java

	public Object getProxy(ClassLoader classLoader) {
		return createAopProxy().getProxy(classLoader);
	}
    // createAopProxy()方法就是决定究竟创建何种类型的proxy
	protected final synchronized AopProxy createAopProxy() {
		if (!this.active) {
			activate();
		}
        // 关键方法createAopProxy()
		return getAopProxyFactory().createAopProxy(this);
	}
	
    // createAopProxy()
	public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
        // 1.config.isOptimize()是否使用优化的代理策略，目前使用与CGLIB
        // config.isProxyTargetClass() 是否目标类本身被代理而不是目标类的接口
        // hasNoUserSuppliedProxyInterfaces()是否存在代理接口
		if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {
			Class<?> targetClass = config.getTargetClass();
			if (targetClass == null) {
				throw new AopConfigException("TargetSource cannot determine target class: " +
						"Either an interface or a target is required for proxy creation.");
			}
            
            // 2.如果目标类是接口类（目标对象实现了接口），则直接使用JDKproxy
			if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
				return new JdkDynamicAopProxy(config);
			}
            
            // 3.其他情况则使用CGLIBproxy
			return new ObjenesisCglibAopProxy(config);
		}
		else {
			return new JdkDynamicAopProxy(config);
		}
	}
```

getProxy()方法

```java

   final class JdkDynamicAopProxy implements AopProxy, InvocationHandler, Serializable// JdkDynamicAopProxy类结构，由此可知，其实现了InvocationHandler，则必定有invoke方法，来被调用，也就是用户调用bean相关方法时，此invoke()被真正调用
   // getProxy()
   public Object getProxy(ClassLoader classLoader) {
   	if (logger.isDebugEnabled()) {
   		logger.debug("Creating JDK dynamic proxy: target source is " + this.advised.getTargetSource());
   	}
   	Class<?>[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);
   	findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);
       
       // JDK proxy 动态代理的标准用法
   	return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);
   }
```

invoke()方法

```java

    //使用了JDK动态代理模式，真正的方法执行在invoke()方法里，看到这里在想一下上面动态代理的例子，是不是就完全明白Spring源码实现动态代理的原理了。
			public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		MethodInvocation invocation;
		Object oldProxy = null;
		boolean setProxyContext = false;
 
		TargetSource targetSource = this.advised.targetSource;
		Class<?> targetClass = null;
		Object target = null;
 
		try {
            // 1.以下的几个判断，主要是为了判断method是否为equals、hashCode等Object的方法
			if (!this.equalsDefined && AopUtils.isEqualsMethod(method)) {
				// The target does not implement the equals(Object) method itself.
				return equals(args[0]);
			}
			else if (!this.hashCodeDefined && AopUtils.isHashCodeMethod(method)) {
				// The target does not implement the hashCode() method itself.
				return hashCode();
			}
			else if (method.getDeclaringClass() == DecoratingProxy.class) {
				// There is only getDecoratedClass() declared -> dispatch to proxy config.
				return AopProxyUtils.ultimateTargetClass(this.advised);
			}
			else if (!this.advised.opaque && method.getDeclaringClass().isInterface() &&
					method.getDeclaringClass().isAssignableFrom(Advised.class)) {
				// Service invocations on ProxyConfig with the proxy config...
				return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);
			}
 
			Object retVal;
 
			if (this.advised.exposeProxy) {
				// Make invocation available if necessary.
				oldProxy = AopContext.setCurrentProxy(proxy);
				setProxyContext = true;
			}
 
			// May be null. Get as late as possible to minimize the time we "own" the target,
			// in case it comes from a pool.
			target = targetSource.getTarget();
			if (target != null) {
				targetClass = target.getClass();
			}
			// 2.获取当前bean被拦截方法链表
			List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);
 
			// 3.如果为空，则直接调用target的method
			if (chain.isEmpty()) {
				Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);
				retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);
			}
            // 4.不为空，则逐一调用chain中的每一个拦截方法的proceed，这里的一系列执行的原因以及proceed执行的内容，我 在这里就不详细讲了，大家感兴趣可以自己去研读哈
			else {
				// We need to create a method invocation...
				invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);
				// Proceed to the joinpoint through the interceptor chain.
				retVal = invocation.proceed();
			}
 
			...
			return retVal;
		}
	}
	}
```

### 异常处理

java异常类的结构层次图：

![java异常](/img/java异常.jpg)

> 在Java中，所有异常类的父类是Throwable类，Error类是error类型异常的父类，Exception类是exception类型异常的父类，RuntimeException类是所有运行时异常的父类，RuntimeException以外的并且继承Exception的类是非运行时异常。
>
> 　　典型的RuntimeException包括NullPointerException、IndexOutOfBoundsException、IllegalArgumentException等。
>
> 　　典型的非RuntimeException包括IOException、SQLException等。

### IO 流

https://www.cnblogs.com/wugongzi/p/12092326.html

***IO流主要是用于操作文件***

IO流总览：

![IO流总览](/img/IO流总览.png)

java IO系统

![IO系统](/img/IO系统.jpg)

- 字符流

  - Writer是字符输出流的基类，Writer的主要方法如下：

    > ```java
    > Writer append(char c) 将指定的字符附加到此作者
    > Writer append(CharSequence csq) 将指定的字符序列附加到此作者
    > Writer append(CharSequence csq, int start, int end) 将指定字符序列的子序列附加到此作writer
    > abstract void close() 关闭流，先刷新
    > abstract void flush() 刷新流 
    > void write(char[] cbuf) 写入一个字符数组。 
    > abstract void write(char[] cbuf, int off, int len) 写入字符数组的一部分 
    > void write(int c) 写一个字符 
    > void write(String str) 写一个字符串 
    > void write(String str, int off, int len) 写一个字符串的一部分
    > ```

  - FileWriter

    - FileWriter构造方法

      > ```java
      > OutputStreamWriter(OutputStream out) 创建一个使用默认字符编码的OutputStreamWriter
      > OutputStreamWriter(OutputStream out, String charsetName) 创建一个使用命名字符集的OutputStreamWriter
      > OutputStreamWriter(OutputStream out, Charset cs) 创建一个使用给定字符集的OutputStreamWriter
      > OutputStreamWriter(OutputStream out, CharsetEncoder enc) 创建一个使用给定字符集编码器的OutputStreamWriter
      > ```

    - FileWriter方法列表

      > ```java
      > Writer append​(CharSequence csq) 将指定的字符序列附加到此作者。 
      > Writer append​(CharSequence csq, int start, int end) 将指定字符序列的子序列附加到此作者。 
      > void close​() 关闭流，先刷新。 
      > void flush​() 刷新流。 
      > String getEncoding​() 返回此流使用的字符编码的名称。 
      > void write​(char[] cbuf, int off, int len) 写入字符数组的一部分。 
      > void write​(int c) 写一个字符 
      > void write​(String str, int off, int len) 写一个字符串的一部分。
      > ```

  - 其他

    - BufferedWriter 是缓冲字符输出流。它继承于Writer
    - CharArrayReader 用于写入字符，它继承于Writer。操作的数据是以字符为单位！
    - FilterWriter是字符类型的过滤输出流
    - PrintWriter 是字符类型的打印输出流，它继承于Writer。

- Reader字符输入流

  有输出流那么当然就有输入流，Reader是字符输入流的基类，Reader的方法列表如下：

  > ```java
  > abstract void close​() 关闭流并释放与之相关联的任何系统资源。 
  > void mark​(int readAheadLimit) 标记流中的当前位置。 
  > boolean markSupported​() 告诉这个流是否支持mark（）操作。 
  > int read​() 读一个字符 
  > int read​(char[] cbuf) 将字符读入数组。 
  > abstract int read​(char[] cbuf, int off, int len) 将字符读入数组的一部分。 
  > int read​(CharBuffer target) 尝试将字符读入指定的字符缓冲区。 
  > boolean ready​() 告诉这个流是否准备好被读取。 
  > void reset​() 重置流。 
  > long skip​(long n) 跳过字符 
  > ```

  类型：

  - FileReader
  - BufferedReader

- 字节流

  字节流的基本操作和字符流类相同，但它不仅可以操作字符，还可以操作其他媒体文件。

  - InputStream类是字节输入流的抽象类，是所有字节输入流的父类

    > InputStream的常用方法：
    >
    > ```java
    > int available​() 从下一次调用此输入流的方法返回可从该输入流读取（或跳过）的字节数，而不会阻塞。 
    > void close​() 关闭此输入流并释放与流相关联的任何系统资源。 
    > void mark​(int readlimit) 标记此输入流中的当前位置。 
    > boolean markSupported​() 测试此输入流是否支持 mark和 reset方法。 
    > abstract int read​() 从输入流读取数据的下一个字节。 
    > int read​(byte[] b) 从输入流中读取一些字节数，并将它们存储到缓冲器阵列 b 。 
    > int read​(byte[] b, int off, int len) 从输入流读取最多 len个字节的数据到字节数组。 
    > byte[] readAllBytes​() 从输入流读取所有剩余字节。 
    > int readNBytes​(byte[] b, int off, int len) 将所请求的字节数从输入流读入给定的字节数组。 
    > void reset​() 将此流重新定位到最后在此输入流上调用 mark方法时的位置。 
    > long skip​(long n) 跳过并丢弃来自此输入流的 n字节的数据。 
    > long transferTo​(OutputStream out) 从该输入流中读取所有字节，并按读取的顺序将字节写入给定的输出流。
    > ```

    - FileInputStream

  - OutputStream
    - FileOutputStream

  

- File

  JavaIo流中还有一个非常常用的类：File。File 是“**文件**”和“**目录路径名**”的抽象表示形式。

  

### 反射

> 反射就是把Java类中的各个成分映射成一个个的Java对象。即在运行状态中，对于任意一个类，都能够知道这个类的所以属性和方法；对于任意一个对象，都能调用它的任意一个方法和属性。这种动态获取信息及动态调用对象方法的功能叫Java的反射机制。

#### Java反射机制主要提供了以下功能：

- 在运行时判断任意一个对象所属的类。
- 在运行时构造任意一个类的对象。
- 在运行时判断任意一个类所具有的成员变量和方法。
- 在运行时调用任意一个对象的方法。
- 生成动态代理。

#### 反射机制相关类：

Java中主要由以下的类来实现Java反射机制（这些类都位于java.lang.reflect包中）：

- Class类：代表一个类。 Field类：代表类的成员变量（成员变量也称为类的属性）。
- Method类：代表类的方法。
- Constructor类：代表类的构造方法。
- Array类：提供了动态创建数组，以及访问数组的元素的静态方法。

#### 反射的使用

　　下面分步说明以下如何通过反射获取我们需要的内容。

　　我们先随意写一个Customer类（就是一个PO类），然后看看如何通过反射对这个类进行操作。

- 先随意写一个Customer类（就是一个PO类），然后看看如何通过反射对这个类进行操作。

  ```java
  public class Customer {
      private Long id;
      private String name;
      private int age;
      
      public Customer() {}
  
      public Customer(String name,int age) {
          this.name = name;
          this.age = age;
      }
  
      public Long getId() {
          return id;
      }
      public void setId(Long id) {
          this.id=id;
      }
      public String getName() {
          return name;
      }
      public void setName(String name) {
          this.name=name;
      }
      public int getAge() {
          return age;
      }
      public void setAge(int age) {
          this.age=age;
      }
  
  }
  ```

- 新建ReflectTester类

  ```这个类用来演示Reflection API的基本使用方法。这里自定义的copy方法是用来创建一个和参数objcet同样类型的对象，然后把object对象中的所有属性拷贝到新建的对象中，并将其返回。```

  ```java
  import java.lang.reflect.Field;
  import java.lang.reflect.Method;
  
  public class ReflectTester {
  
      public Object copy(Object object) throws Exception{
          //获得对象的类型
          Class classType=object.getClass();
          System.out.println("Class:"+classType.getName());
  
          //通过默认构造方法创建一个新的对象
          Object objectCopy=classType.getConstructor(new Class[]{}).newInstance(new Object[]{});
  
          //获得对象的所有属性
          Field fields[]=classType.getDeclaredFields();
  
          for(int i=0; i<fields.length;i++){
              Field field=fields[i];
  
              String fieldName=field.getName();
              String firstLetter=fieldName.substring(0,1).toUpperCase();
              //获得和属性对应的getXXX()方法的名字
              String getMethodName="get"+firstLetter+fieldName.substring(1);
              //获得和属性对应的setXXX()方法的名字
              String setMethodName="set"+firstLetter+fieldName.substring(1);
  
              //获得和属性对应的getXXX()方法
              Method getMethod=classType.getMethod(getMethodName,new Class[]{});
              //获得和属性对应的setXXX()方法
              Method setMethod=classType.getMethod(setMethodName,new Class[]{field.getType()});
  
              //调用原对象的getXXX()方法
              Object value=getMethod.invoke(object,new Object[]{});
              System.out.println(fieldName+":"+value);
              //调用拷贝对象的setXXX()方法
              setMethod.invoke(objectCopy,new Object[]{value});
          }
          return objectCopy;
      }
  
  }
  ```

  #### 反射的原理

  